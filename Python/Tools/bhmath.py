from Tools.log import log, Severity

from math import sqrt
from enum import IntEnum
from typing import Union, Iterable, Callable, Iterator, Any, Self
from numbers import Complex, Real, Rational, Integral

class SetTypes(IntEnum):
	Empty=0
	All=1
     
class Set:
    class _Generator:
        class _Internal:
            def __init__(self, gen, conditions):
                self.iter = iter(gen)
                self.conditions = conditions
                self.counter = set([])
            def _meetsConditions(self, x):
                return set([cond(x) for cond in self.conditions])=={True}
            def __iter__(self):
                return self
            def __next__(self):
                while not self._meetsConditions(x:=self.iter.__next__()) or x in self.counter: pass
                self.counter.add(x)
                return x

        def __init__(self, gen, conditions):
            self.gen = gen
            self.conditions = conditions
        def __call__(self):
            return self.__iter__()
        def __iter__(self):
            return self._Internal(iter(self.gen), self.conditions)

    class _NotIterable:
        def __init__(self, msg):
            self.msg = msg
        def __call__(self):
            return self
        def __iter__(self):
            return self
        def __next__(self)->None:
            log(self.msg, Severity.crash)
            raise StopIteration()

    def _meetsConditions(self, x):
        for cond in self._conditions:
            try:
                v = cond(x)
                if not v: return False
            except: return False
        return True

    def __init__(self, base:Union[SetTypes, set, list, Iterable], conditions:Iterable[Callable[[Any], bool]] = [lambda x:True])->None:
        """Creates a new Set object

        args:
            base (set, list or Iterable): When type is set, Set or list, the Set will contain the (finite) number of items in the base with the conditions applied. When type is Iterable, the set is assumed infite, but any item can be generated by the generator, either sequentially or by index. When type is Sets, the base will be the specified enum value.
            conditions (function): Specifies extra conditions on the base that must be met for an item to be in the new Set
        """

        if type(base) == SetTypes:
            if base == SetTypes.Empty:
                self._finite = {}
                self._conditions = []
                self._generator = self._finite.__iter__
            elif base == SetTypes.All:
                self._finite = SetTypes.All
                self._conditions = conditions
                self._generator = self._NotIterable("This Set is infinite and provides no generator.")
            else:
                log("Unkown Sets enum!", Severity.crash)
        elif type(base) == set or type(base) == list:
            self._conditions = conditions
            self._finite = set([x for x in base if self._meetsConditions(x)]) # filter out all elements of base that do not meet the conditions criteria
            self._conditions = [] # after all conditions are applied to the _finite internal set, they serve no more purpose
            self._generator = self._finite.__iter__
        elif isinstance(base, Iterable):
            self._finite = None
            self._conditions = conditions
            self._generator = self._Generator(base, conditions)
        else:
            log("Unsupported type for Set base!", Severity.crash)

    def contains(self, x):
        if self._finite == SetTypes.All:
            return self._meetsConditions(x)
        if self._finite != None:
            return x in self._finite
        # We are dealing with a set made up of conditions and a generator
        if not self._meetsConditions(x):
            return False
        return x in self._generator()

    def __contains__(self, x):
        return self.contains(x)

    def __str__(self):
        if self._finite == SetTypes.All:
            return "Î© with conditions"
        if self._finite != None:
            return str(self._finite)
        # We are dealing with a set made up of conditions and a generator
        return str(set([x for x in self._generator() if self._meetsConditions(x)]))
    
    def __iter__(self)->Iterator:
        return self._generator()

class MatBase:
    def __init__(self, dims:tuple[int], *args:Iterable[Complex]):
        self.dims = dims
        self.args = list(*args) # assume row1, row2, ... ordering
        if len(self.dims) != 2: raise ValueError(f"Invalid number of dimensions for a Matrix (needs 2)")
        if len(self.args) != dims[0]*dims[1]: raise ValueError(f"Invalid number of arguments for Matrix with dimensions {dims}")
        """TODO: implement rest"""

class VecBase(MatBase):
    def __init__(self, dim:int, *args:Iterable[Complex]):
        self.dim = dim
        self.args = list(*args)
        if len(self.args) != self.dim: raise ValueError(f"Invalid number of arguments for Vector with dimension {dim}")

    @property
    def x(self): return self.args[0]
    @property
    def y(self): return self.args[1]
    @property
    def z(self): return self.args[2]
    @property
    def w(self): return self.args[3]
    @x.setter
    def x(self, value:Complex): self.args[0] = value
    @y.setter
    def y(self, value:Complex): self.args[1] = value
    @z.setter
    def z(self, value:Complex): self.args[2] = value
    @w.setter
    def w(self, value:Complex): self.args[3] = value

    def __repr__(self) -> str:
        return f"Vec{self.dim}({', '.join([repr(x) for x in self.args])})"
    def __eq__(self, value: object) -> bool:
        if not isinstance(value, VecBase): return False
        if value.dim != self.dim: return False
        if set([value.args[i]==self.args[i] for i in range(self.dim)]) != {True}: return False
        return True
    def __hash__(self) -> int:
        return hash(self.args)
    def __bool__(self) -> bool:
        return set([x==0 for x in self.args]) != {False}
    def __complex__(self) -> complex:
        if self.dim != 2: return NotImplemented
        return complex(self.x, self.y)
    def __len__(self) -> int:
        return self.dim
    def __iter__(self) -> Iterator:
        return iter(self.args)
    def __getitem__(self, key:int) -> complex:
        return self.args[key]
    def __setitem__(self, key:int, value:complex) -> None:
        self.args[key] = value
    def __contains__(self, value:object) -> bool:
        return value in self.args
    def __add__(self, y:object) -> Self:
        if not isinstance(y, VecBase): return NotImplemented
        if y.dim != self.dim: return NotImplemented
        return VecBase(self.dim, [self.args[i]+y[i] for i in range(self.dim)])
    def __sub__(self, y:object) -> Self:
        if not isinstance(y, VecBase): return NotImplemented
        if y.dim != self.dim: return NotImplemented
        return VecBase(self.dim, [self.args[i]-y[i] for i in range(self.dim)])
    def __mul__(self, y:object) -> Self:
        if not isinstance(y, Complex): return NotImplemented
        return VecBase(self.dim, [y*x for x in self.args])
    def __rmul__(self, y:object) -> Self:
        if not isinstance(y, Complex): return NotImplemented
        return VecBase(self.dim, [y*x for x in self.args])
    def __truediv__(self, y:object) -> Self:
        return 1/y * self
    def __rmul__(self, y:object) -> Self:
        if not isinstance(y, Complex): return NotImplemented
        return VecBase(self.dim, [y*x for x in self.args])
    def __neg__(self) -> Self:
        return VecBase(self.dim, [-x for x in self.args])
    def __pos__(self) -> Self:
        return VecBase(self.dim, [x for x in self.args])
    def __abs__(self) -> Self:
        return sqrt(sum([x*x for x in self.args]))







def Vec(dim:int)->Callable[[Iterable[Complex]], VecBase]:
    if dim < 1: raise ValueError("Dimension must be greater than 0")
    def constructor(*args:Iterable[Complex])->VecBase:
        return VecBase(dim, args)
    return constructor

Vec2 = Vec(2)
Vec3 = Vec(3)
Vec4 = Vec(4)


class Sets:
    C = Set(SetTypes.All, [lambda x:isinstance(x, Complex)])
    R = Set(SetTypes.All, [lambda x:isinstance(x, Real)])
    Q = Set(SetTypes.All, [lambda x:isinstance(x, Rational)]) # any Real number that has numerator and denominator properties
    Z = Set(SetTypes.All, [lambda x:isinstance(x, Integral)])
    N = Set(SetTypes.All, [lambda x:(x in Sets.Z) and x >= 0]) # includes 0

    C2 = Set(SetTypes.All, [lambda v:isinstance(v, VecBase) and v.dim == 2])
    R2 = Set(SetTypes.All, [lambda v:v in Sets.C2] + [lambda v: v[i] in Sets.R for i in range(2)])
    Q2 = Set(SetTypes.All, [lambda v:v in Sets.C2] + [lambda v: v[i] in Sets.Q for i in range(2)])

    C3 = Set(SetTypes.All, [lambda v:isinstance(v, VecBase) and v.dim == 3])
    R3 = Set(SetTypes.All, [lambda v:v in Sets.C3] + [lambda v: v[i] in Sets.R for i in range(3)])
    Q3 = Set(SetTypes.All, [lambda v:v in Sets.C3] + [lambda v: v[i] in Sets.Q for i in range(3)])
    
    C4 = Set(SetTypes.All, [lambda v:isinstance(v, VecBase) and v.dim == 4])
    R4 = Set(SetTypes.All, [lambda v:v in Sets.C4] + [lambda v: v[i] in Sets.R for i in range(4)])
    Q4 = Set(SetTypes.All, [lambda v:v in Sets.C4] + [lambda v: v[i] in Sets.Q for i in range(4)])